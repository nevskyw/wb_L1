https://docs.google.com/document/d/15wTlKrMy0clrp-qnIuW1u1Q0Z0W9MyGab5rWMf4kchQ/edit#

1. Какой самый эффективный способ конкатенации строк? Strings.Builder{}

2. Что такое интерфейсы, как они применяются в Go? Это абстракция, которая содержит в себе методы, которые должны быть у структуры, чтобы ее можно было использовать в качестве возвращаемого значения или принимаего аргумента функции.

3. Чем отличаются RWMutex от Mutex?
   1. Чем отличаются RWMutex от Mutex?
    У RWMutex появляется функция RLock и RUnlock, с помощью которых мы так же как и Lock ограничиваем запись в переменную, исключительно для данной горутины, но если другая горутина, так же, использует метод RLock, то она сможет считывать из переменной одновременно с первой горутиной.
    Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

4. Чем отличаются буферизированные и не буферизированные каналы? Небуферизированный канал всегда блокирует горутину, до чтения\записи Буферизированный канал не всегда блокирует горутину. В буферизированный канал можно писать до конца буфера, без блокировки. А блокировка будет вызвана только записью сверх буфера.

5. Какой размер у структуры struct{}{}? 0 byte. Там, где в мапе нужны только ключи - можно всегда делать значение struct{}{}

  import (
      "fmt"
      "unsafe"
  )

  type S1 struct {
      f1 int
  }

  func main() {
      s1 := S1{}
      s2 := struct{}{}

      fmt.Printf("s1 size: %v\n", unsafe.Sizeof(s1))
      fmt.Printf("s2 size: %v\n", unsafe.Sizeof(s2))
  }

6. Есть ли в Go перегрузка методов или операторов? У методов и операторов нет перегрузки.

 1. В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям или использование интерфейсов.

 2. Диспетчеризация методов упрощается, если не требуется выполнять сопоставление типов. Опыт работы с другими языками показал нам, что наличие различных методов с одинаковыми именами, но разными сигнатурами иногда полезно, но на практике это также может быть запутанным и хрупким. Совпадение только по имени и требование согласованности типов было основным упрощающим решением в системе типов Go.

 3. Перегрузка операторов — это способ, с помощью которого операторы могут выполнять операции, определенные пользователями. Операторы ведут себя в соответствии с переданными аргументами. Например, в C ++ + оператор может использоваться для объединения строк, а также сложения двух целых чисел. Значение «+» также может быть определено пользователем и изменено в соответствии с потребностями программы. В JavaScript операция типа '1' + 1 приведет к выводу строки "11" из-за более высокого приоритета строк. Такие определения недопустимы в Go, операторы работают строго и выполняют операции только с определенными типами данных аргументов.

7. В какой последовательности будут выведены элементы map[int]int? 
  1. Будет выведено по последовательности ключей - map[0:1 1:124 2:281]

	m := make(map[int]int)

	m[0] = 1
	m[1] = 124
	m[2] = 281

	fmt.Println(m)

8. В чем разница make и new? 

 1. make выделяет память и возвращает саму сущность создаваемую make'ом и работает только с картой, срезом и каналами. 

 2. New выделяет память и возвращает указатель на сущность. в случае со срезом и картой len и cap будут 0

9. Сколько существует способов задать переменную типа slice или map? два: make и инициировать в ручную

10. Что выведет данная программа и почему? 

// у нас в памяти компьютера создается 2 переменные p, одна находитсяв функции, а другая в майне
func update(p *int) { // копирование адреса
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}

11. Что выведет данная программа и почему? 
 1. - Надо передать указатель на wg, потому что мы хотим сказать, что мы обращаемся к прошлой wg и не определяем новую
 2. - wg можно удалить, горутина и так имеет доступ к wg

func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) { // *sync.WaitGroup
			fmt.Println(i)
			wg.Done()
		}(wg, i)                            // (&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

12. Что выведет данная программа и почему? выведет: 0

// n := 1, n++  работают внутри оператора if, но не взаимодействуют с мэйном
func main() { 
	n := 0
	if true {
	    n := 1 
		n++
	}
	fmt.Println(n)
}


???? 13. Что выведет данная программа и почему? выведет: [100 2 3 4 5] 

 1. а раз срез - ссылка на массив
    а массив у нас новый
    то.. естественно, срез тоже будет новый

func someAction(v []int8, b int8) {
  v[0] = 100 // 
  v = append(v, b) // создает новый массив, где указывается ссылка на срез, но массив у нас новый                          
  //и мы его  не передаем в функции мэйн
}

func main() {
  a := []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}





???? 14. Что выведет данная программа и почему?

 1. Вывод: [b b a][a a]


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)

  fmt.Print(slice)
}
